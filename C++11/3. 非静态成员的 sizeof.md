1.sizeof简介
sizeof 是一个C/C++中的一个关键字，它是一个运算符，其作用是取得一个对象（数据类型或数据对象）的长度（即占用内存的大小，以byte为单位）。其中类型包含基本数据类型（不包含void)、用户自定义类型（结构体、类）、函数类型。数据对象是指用前面提到的类型定义的普通变量和指针变量（包含void指针）。
+ sizeof是运算符，不是函数
+ sizeof不能求得void类型的长度
void是“空类型”，
+ sizeof能求得void类型的指针的长度
  地址所占的存储空间，这个是确定的。
+ sizeof可以获取静态分配内存的数组的长度
+ sizeof无法获取动态分配的内存的大小
+ sizeof不能对不完整的数组求长度
+ 当表达式作为sizeof的操作数时，它返回表达式的计算结果的类型大小，但是它不对表达式求值
+ sizeof可以对函数调用求大小，并且求得的大小等于返回类型，但是不执行函数体
对于函数
```
int func(int& num, int &inc) { ... }
```
我们对函数调用求大小：
```
std::cout << sizeof(func(1, 2)) << std::endl;
```
执行上面的代码，输出4，并且不会执行函数func。
+ sizeof求得的结构体（及其对象）的大小并不等于各个数据成员对象的大小之和
因为结构体的成员对齐，
+ sizeof不能用于求结构体的位域成员的大小，但是可以求得包含位域成员的结构体的大小
在结构体的成员变量后面跟上一个冒号+一个整数，就代表位域，如：
```c++
struct A {
  bool b:1;
  char ch1:4;
  chat ch2:4;
};
```
对A的成员变量进行sizeof运算均不能通过编译，sizeof以byte为单位返回操作数的大小。对包含位域的结构体进行sizeof运算是可以的。
2. C++11对sizeof的扩展
在C++98标准中，对非静态成员变量使用sizeof是不能够通过编译的，在C++11中，对非静态成员变量使用sizeof操作是合法的。
c++98:
```c++
sizeof(((Pepole*)0)->hand)
```
c++11:
```c++
sizeof(People::hand)
```
